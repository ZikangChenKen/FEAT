package main.rice.node;

import main.rice.obj.AIterablePyObj;
import main.rice.obj.APyObj;
import java.util.*;

/**
 * An abstract class whose instances represent generators for iterable Python objects
 * (list, tuple, set, or string). Includes common functionality for generating
 * permutations, though some of the individual sub-classes need to do their own
 * post-processing.
 *
 * @param <OuterType> the outer type of object generated by this node; if we invoke
 *                    this.genExVals(), it will return a Set<OuterType<InnerType>>
 * @param <InnerType> the type of object generated by the leftChild node, which represents
 *                    the type of elements in this iterable object; if we invoke
 *                    this.leftChild.genExVals(), it will return a Set<InnerType>
 */
public abstract class AIterablePyNode<OuterType extends AIterablePyObj<InnerType>,
        InnerType extends APyObj> extends APyNode<OuterType> {

    /**
     * Overrides the leftChild in the superclass (APyNode) with a more specific type: a
     * generator of InnerType objects.
     */
    protected APyNode<InnerType> leftChild;

    /**
     * Returns the left child node.
     *
     * @return the left child node
     */
    @Override
    public APyNode<InnerType> getLeftChild() {
        return this.leftChild;
    }

    /**
     * Generates all valid OuterType objects within the exhaustive domain; begins by
     * generating all valid elements, and then finds all permutations of them of valid
     * length (as constrained by the exhaustive domain).
     *
     * @return a set of OuterTypes comprising the exhaustive domain
     */
    @Override
    public Set<OuterType> genExVals() {
        Set<InnerType> innerVals = this.leftChild.genExVals();
        return this.genPerms(this.exDomainMax(), innerVals);
    }

    /**
     * Generates a single valid OuterType object within the random domain; begins by
     * randomly generating a valid length (as constrained by the random domain), and then
     * randomly generates valid elements.
     *
     * @return a single OuterType object selected from the random domain
     */
    @Override
    public OuterType genRandVal() {
        // Randomly select the size, n
        int length = this.ranDomainChoice().intValue();

        // Randomly select n inner values
        List<InnerType> list = new ArrayList<>();
        for (int idx = 0; idx < length; idx++) {
            InnerType childVal = this.genRandInnerVal();
            list.add(childVal);
        }
        return this.genObj(list);
    }

    /**
     * Helper function for generating one random InnerType object.
     *
     * @return a randomly-generated object of type InnerType
     */
    protected InnerType genRandInnerVal() {
        return this.leftChild.genRandVal();
    }

    /**
     * Helper function for generating an object of the correct OuterType; will be
     * overridden in the subclasses, where the OuterType is known.
     *
     * @param innerVals the elements to be contained by the generated object
     * @return an OuterType object encapsulating the innerVals
     */
    protected abstract OuterType genObj(List<InnerType> innerVals);

    /**
     * Helper function that generates all permutations of multiple sizes.
     *
     * @param currSize  the max size permutation to be generated
     * @param innerVals the set of values that can be contained within the iterable being
     *                  randomly-generated
     * @return all permutations of innerVals, according to the input specifications
     */
    protected Set<OuterType> genPerms(int currSize, Set<InnerType> innerVals) {
        // BASE CASE: size 0 -> return a set containing only the empty list
        if (currSize == 0) {
            Set<OuterType> perms = new HashSet<>();
            perms.add(this.genObj(new ArrayList<>()));
            return perms;
        }

        // RECURSIVE CASE:
        // Get all permutations that are of length size - 1
        Set<OuterType> oneShorter = this.genPerms(currSize - 1, innerVals);
        Set<OuterType> perms = new HashSet<>();

        // Iterate over each shorter "list" (could actually be a PyListObj, PySetObj, PyTupleObj,
        // or PyStringObj)
        for (OuterType listObj : oneShorter) {

            // Only keep around the smaller version if we wanted that size too
            int listSize = listObj.getValue().size();
            if (this.exDomain.contains(listSize)) {
                perms.add(listObj);
            }

            // For efficiency, let's avoid generating duplicates by only adding to the largest
            // elements of shorterPerms
            if (listSize < currSize - 1) {
                continue;
            }

            // Construct all new lists that result from adding val (a possible inner val) to listObj
            for (InnerType val : innerVals) {
                // Make sure to copt the internal value so as not to mutate the original
                List<InnerType> copy = new ArrayList<>(listObj.getValue());
                copy.add(val);
                OuterType obj = this.genObj(copy);

                // Only keep this around if it's the correct size (necessary for PySetObj)
                if (obj.getValue().size() == currSize) {
                    perms.add(obj);
                }
            }
        }
        return perms;
    }
}