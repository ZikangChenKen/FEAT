package main.rice.node;

import main.rice.obj.APyObj;
import main.rice.obj.PyDictObj;
import java.util.*;

/**
 * A representation of a node for generating PyDictObjs.
 *
 * @param <KeyType> the type of object generated by the leftChild node, which represents
 *                  the type of the keys in the dictionary; if we invoke
 *                  this.leftChild.genExVals(), it will return List<KeyType>
 * @param <ValType> the type of object generated by the rightChild node, which represents
 *                  the type of the values in the dictionary; if we invoke
 *                  this.leftChild.genExVals(), it will return List<ValType>
 */
public class PyDictNode<KeyType extends APyObj, ValType extends APyObj>
        extends APyNode<PyDictObj<KeyType, ValType>> {

    /**
     * Overrides the leftChild in the superclass (APyNode) with a more specific type: a
     * generator of KeyType objects.
     */
    protected APyNode<KeyType> leftChild;

    /**
     * Overrides the leftChild in the superclass (APyNode) with a more specific type: a
     * generator of ValType objects.
     */
    protected APyNode<ValType> rightChild;

    /**
     * Constructor for a PyDictNode; stores references to the keyChild (this.leftChild)
     * and valChild (this.rightChild).
     *
     * @param keyChild a node representing the valid keys for this dictionary
     * @param valChild a node representing the valid values for this dictionary
     */
    public PyDictNode(APyNode<KeyType> keyChild, APyNode<ValType> valChild) {
        this.leftChild = keyChild;
        this.rightChild = valChild;
    }

    /**
     * Returns the left child node.
     *
     * @return the left child node
     */
    @Override
    public APyNode<KeyType> getLeftChild() {
        return this.leftChild;
    }

    /**
     * Returns the right child node.
     *
     * @return the right child node
     */
    @Override
    public APyNode<ValType> getRightChild() {
        return this.rightChild;
    }

    /**
     * Generates all valid PyDictObjs within the exhaustive domain; begins by generating
     * all valid keys and values, and then generates all permutations of (key, value)
     * pairs of valid length (as constrained by the exhaustive domain).
     *
     * @return a set of PyDictObjs comprising the exhaustive domain
     */
    @Override
    public Set<PyDictObj<KeyType, ValType>> genExVals() {
        // Generate all valid keys and values
        Set<KeyType> keyVals = this.leftChild.genExVals();
        Set<ValType> valVals = this.rightChild.genExVals();

        // Generate all permutations of valid (key, value) pairs of valid length
        return this.genDictPerms(keyVals, valVals);
    }

    /**
     * Generates a single valid PyDictObj within the random domain; begins by randomly
     * selecting the size, n (number of (key, value) pairs), and then randomly selects
     * valid (key, value) pairs until there are n unique (key, value) pairs.
     *
     * @return a single PyDictObj selected from the random domain
     */
    @Override
    public PyDictObj<KeyType, ValType> genRandVal() {
        // Randomly select the size, n
        int size = this.ranDomainChoice().intValue();

        // Randomly select n (key, value) pairs; make sure to continuously monitor the
        // size, as we could generate the same key twice resulting in the size not
        // increasing from one iteration to the next
        Map<KeyType, ValType> map = new HashMap<>();
        while (map.size() < size) {
            KeyType key = this.leftChild.genRandVal();
            ValType val = this.rightChild.genRandVal();
            map.put(key, val);
        }
        return new PyDictObj<>(map);
    }

    /**
     * Generate all permutations of sets of (key, value) pairs where key is an element of
     * keyVals and value is an element of valVals, of size up to and including the input
     * size.
     *
     * @param size    the max size permutation to be generated
     * @param keyVals the set of valid keys that can be contained within the dictionary
     *                being generated
     * @param valVals the set of valid values that can be contained within the dictionary
     *                being generated
     * @return all permutations of valid (key, value) pairs of length up to and including
     * the input size
     */
    private Set<PyDictObj<KeyType, ValType>> genPermsHelper(int size,
                                                            Set<KeyType> keyVals, Set<ValType> valVals) {
        // BASE CASE: size 0 -> return a set containing only the empty dictionary
        if (size == 0) {
            Set<PyDictObj<KeyType, ValType>> perms = new HashSet<>();
            perms.add(new PyDictObj<>(new HashMap<>()));
            return perms;
        }

        // RECURSIVE CASE:
        // Get all permutations that are of length size - 1
        Set<PyDictObj<KeyType, ValType>> oneShorter =
                this.genPermsHelper(size - 1, keyVals, valVals);

        // Iterate over each shorter dictionary, adding each possible single (key,
        // value) pair to it
        Set<PyDictObj<KeyType, ValType>> perms = new HashSet<>(oneShorter);
        for (PyDictObj<KeyType, ValType> dictObj : oneShorter) {
            // Extract the internal HashMap representation
            Map<KeyType, ValType> dict = dictObj.getValue();
            if (dict.size() < size - 1) {
                // For efficiency, let's avoid generating duplicates
                continue;
            }

            // Construct all new dictionaries that result from adding (key, value) to dict
            for (KeyType key : keyVals) {
                for (ValType val : valVals) {
                    // Make sure to clone dict so as not to mutate the original
                    Map<KeyType, ValType> dictClone = new HashMap<>(dict);
                    dictClone.put(key, val);
                    perms.add(new PyDictObj<>(dictClone));
                }
            }
        }
        return perms;
    }

    /**
     * Generates all permutations of sets of (key, value) pairs where key is an element of
     * keyVals and value is an element of valVals, of size up to and including the max
     * value in this.exDomain.
     *
     * @param keyVals the set of valid keys that can be contained within the dictionary
     *                being generated
     * @param valVals the set of valid values that can be contained within the dictionary
     *                being generated
     * @return all permutations of valid (key, value) pairs of length up to and including
     * the max value in this.exDomain
     */
    private Set<PyDictObj<KeyType, ValType>> genDictPerms(Set<KeyType> keyVals,
                                                          Set<ValType> valVals) {
        // Create all dicts up to (and including) the maximum size
        int maxLength = this.exDomainMax();
        Set<PyDictObj<KeyType, ValType>> allPerms =
                this.genPermsHelper(maxLength, keyVals, valVals);

        // Remove dicts of sizes that are not found in this.domain
        Set<PyDictObj<KeyType, ValType>> finalPerms = new HashSet<>();
        for (PyDictObj<KeyType, ValType> dict : allPerms) {
            if (this.exDomain.contains((dict.getValue()).size())) {
                finalPerms.add(dict);
            }
        }
        return finalPerms;
    }
}